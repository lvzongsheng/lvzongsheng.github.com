<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Coco]]></title>
  <link href="http://lvzongsheng.github.io/atom.xml" rel="self"/>
  <link href="http://lvzongsheng.github.io/"/>
  <updated>2013-09-26T20:06:53+08:00</updated>
  <id>http://lvzongsheng.github.io/</id>
  <author>
    <name><![CDATA[Coco]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[正则表达式]]></title>
    <link href="http://lvzongsheng.github.io/blog/2013/09/22/regular-expression/"/>
    <updated>2013-09-22T07:14:00+08:00</updated>
    <id>http://lvzongsheng.github.io/blog/2013/09/22/regular-expression</id>
    <content type="html"><![CDATA[<h2>正则表达式</h2>

<p>在对文本进行分析处理的时候，少不了会使用正则表达式进行匹配和替换。本文是对自己在学习正则表达式的一些总结。<br/>
正则表达式定义：正则表达式是描述一组字符串的特征的模式，用来匹配特定的字符串。<br/>
在介绍正则表达式之前，说几个在线的测试正则表达式的工具：<br/>
 + <a href="http://www.regexpal.com">Regexpal</a><br/>
它是一个在线的用Javascript实现的正则表达式处理器。它不是正则表达式的完整实现，因此功能并不完整，优点是简洁易用，易于上手。<br/>
 + <a href="http://gskinner.com/RegExr">RegExr</a><br/>
 RegExr内嵌在Flex3中且依赖于ActionScript正则表达式引擎，其使用的正则表达式与Javascript相似。
 <!--more--></p>

<h3>简单的模式匹配</h3>

<pre><code>匹配字符串字面值 eg: abc 匹配abcde中的abc
匹配数字 \d 或者 [0-9]
匹配非数字字符 \D 或者 [^0-9] 或者 [^\d]
匹配单词和非单词字符 \w 或者 [_a-zA-Z0-9]
// \D和\w的区别\D会匹配空格、标点符号（引号、连字符、反斜杠、方括号）等字符，而\w不会，它只匹配字母、数字和下划线。
匹配非单词字符 \W
匹配空白符 \a 或者[ \t\n\r] 包括空格、制表符、换行符、回车符
</code></pre>

<p>在正则表达式中，有大小写的匹配符一般都是相反的作用，也可以使用^来进行取反。</p>

<h3>边界</h3>

<pre><code>行的起始和结束 ^ $
单词边界与非单词边界 \b \B
\\ \b是零宽度断言，表面山会匹配空格或者行起始，但实际上它匹配的是个零宽度的不存在的东西。
使用元字符字面值 \Q \E eg:\Q$\E
</code></pre>

<p>零宽度断言是指匹配宽度为0，满足一定条件的断言。零宽度断言用于查找在某些内容（但不包括这些内容）之前或者之后的东西。所以像\b ^ $都是零宽度断言符。</p>

<h3>选择、分组和后向引用</h3>

<p>选择使用的()中间用|分割，eg:(the|The|THE),值得注意的是使用()也是一次分组。<br/>
捕获分组用的是()，可以通过后向引用重用捕获的内容，\1.<br/>
非捕获分组用的是(?:)<br/>
在实际的字符串匹配中，选择，分组和后向引用是非常常见的功能，所以建议大家好好学习并掌握。</p>

<h3>量词</h3>

<p>量词本身没有什么难度，但在实际的应用中还是会存在一下难度，其中很重要的是贪心与懒惰匹配。
量词自身是贪心的，贪心的量词会先尝试匹配整个字符串，如果失败则退一个字符后再次尝试，这个就是正则匹配回溯的过程，所以整个运算量比较大。<br/>
而懒惰的量词采用了另外一个策略，它从目标位置开始匹配，每次检查字符串的一个字符。懒惰量词需要在普通量词后面加一个？<br/>
占有量词会覆盖整个目标然后尝试寻找匹配内容，但它只尝试一次，不会回溯。占有量词是在普通量词后面添加一个+<br/></p>

<pre><code>举个简单的例子：“simple sample”
贪婪模式 s.+e 匹配simple sample
懒惰模式 s.+?e 匹配simple
占有模式 s.++e 匹配失败
</code></pre>

<h3>环视</h3>

<p>环视是一种非捕获分组，它根据某个模式之前或之后的内容匹配其他模式，环视也称为零宽度断言。<br/>
环视包括正前瞻，反前瞻，正后顾，反后顾。</p>

<pre><code>正前瞻：eg (?i)ancyent (?=marinere)
反前瞻：eg (?i)ancyent (?!marinere)
正后顾：eg (?i)(?&lt;=ancyent) marinere
反后顾：eg (?i)(?&lt;!ancyent) marinere
</code></pre>

<p>本文提到的都是正则表达式中最常用，最重要的几个点，在实际使用中会衍生出各种复杂的表达式，归根到底正则表达式是一种组合的艺术，剖析来看没什么神奇之处，一旦组合到一起，便是让人眼花缭乱。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的遍历]]></title>
    <link href="http://lvzongsheng.github.io/blog/2013/09/06/tree-traversals/"/>
    <updated>2013-09-06T09:39:00+08:00</updated>
    <id>http://lvzongsheng.github.io/blog/2013/09/06/tree-traversals</id>
    <content type="html"><![CDATA[<h2>1 二叉树数据结构</h2>

<p>二叉树数据结构一般有两种，数组和链式结构。</p>

<h3>1.1 数组结构</h3>

<p>我们一般是把数组下标为1的元素作为树的根节点，如果已知一个父节点为n，然后其左孩子为2n，右孩子为2n+1.<br/>优点：对于完全二叉树而言，数组结构简单而且最节省空间。<br/>缺点：对于一般的二叉树而言，比较浪费空间，同时数组结构的二叉树做插入和删除操作时，移动的节点较多。<br/>
关于更多的顺序存储的知识，请<a href="http://student.zjzk.cn/course_ware/data_structure/web/shu/shu6.2.3.1.htm">参考</a>
在实际的编程中，如果更多的情况是进行树的遍历并且树接近完全二叉树，则使用数组结构是比较合适的。</p>

<!--more-->


<h3>1.2 链式结构</h3>

<p>链式结构是最一般化的树形结构的表示方法，其优点是可以表示最一般的树形结构，同时对树的查找，插入和删除代价小。缺点是实现难度稍微负责点，容易出错。</p>

<h2>2 二叉树的遍历</h2>

<p>树的遍历最常用是树的前序，中序，后序和层序遍历。在一般的算法题中，就是根据已经给定的两种遍历结果，求第三种遍历结果。只要掌握了各种遍历方法和树的表示形式，应该解题会比较通畅。<br/>
关于上述题型的总结，可以参见<a href="http://biaobiaoqi.me/blog/2013/04/27/travsal-binary-tree/">二叉树的遍历（递归、非递归）分析</a>和<a href="http://biaobiaoqi.me/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree/">根据前中后序和层序重建二叉树</a><br/>这里总结一下二叉树遍历最一般使用的STL。
在前中后序遍历中，最为常用的还是递归的实现，一般会使用stack或者queue。但在层序遍历中，我们使用的queue，而stack不能实现层序遍历。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress_setup]]></title>
    <link href="http://lvzongsheng.github.io/blog/2013/08/28/octopress-setup/"/>
    <updated>2013-08-28T23:34:00+08:00</updated>
    <id>http://lvzongsheng.github.io/blog/2013/08/28/octopress-setup</id>
    <content type="html"><![CDATA[<p>接触Github有一段时间了，知道Octopress也有一段时间，只是一直没有把它们整合，搭建一个自己的博客。最近自己过得过于混乱，想有个自己的博客来记录生活上的点点滴滴，所以就动手了……</p>

<h2>1 Octopress的安装</h2>

<p>非常感谢室友biaobiaoqi的分享，使自己在Octopress的安装上没有走弯路。<br/>
这里是他的博文链接，对于想安装和定制Octopress的童鞋非常有指导作用。<br/>
<a href="http://biaobiaoqi.me/blog/2013/03/21/building-octopress-in-github-mac/">在github上搭建octopress博客 Mac</a>和<a href="http://biaobiaoqi.me/blog/2013/07/10/decorate-octopress/">定制Octopress</a><br/>
朋友可以参考以上博文来安装和定制Octopress</p>

<!-- more -->


<p>下面是自己经常用到的Octopress及github的命令</p>

<pre><code>#创建一篇博文
rake new_post["post title"] #octopress 将在工作目录的 source/_post/目录下生成相应的 markdown 文件。然后可以使用 mou 工具去修改编辑内容。

#生成预览
rake preview #可以通过 localhost:4000 在本机实时观察最新的编辑效果。

#在线发布
rake deploy #完成编辑后，可以将最新的内容部署到 github 上去。成功后，即可在线访问。

#向 github 提交源文件更新
git add -A
git commit -m "提交内容"
git push origin source //source 是github上的一个分支
</code></pre>

<p>Octopress可以Mou来进行快速和可视化编辑，下面是Mou最常用的语法。</p>

<ul>
<li>加粗和斜体 (单词前后包围**或者__)</li>
<li>有序的列表 （“1.”+space）</li>
<li>无顺序的列表 （“*”+space或者“-”+space）</li>
<li>断行 （2或者更多的空格）</li>
<li>内嵌的代码 （tab或者4个空格）</li>
<li>划掉单词 （单词前后包围~~）
更多信息，请参见<a href="http://mouapp.com">Mou</a></li>
</ul>


<h2>2 Octopress的定制</h2>

<h3>2.1 图片相册</h3>

<p>在个人主页中，我针对自己对摄影的爱好，专门配置了图片相册。我采用的是<a href="http://fancyapps.com/fancybox/">FancyBox</a>的插件。同时也有人根据FancyBox定制了Octopress的第三方<a href="http://tritarget.org/blog/2012/05/07/integrating-photos-into-octopress-using-fancybox-and-plugin/">插件</a></p>

<pre><code>1 Download the fancybox source to /source/fancybox
2 Add fancybox jquery to _include/custom/head.html
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"&gt;&lt;/script&gt;
&lt;link rel="stylesheet" href="http://lvzongsheng.github.io/fancybox/jquery.fancybox.css" type="text/css" media="screen" /&gt;
&lt;script type="text/javascript" src="http://lvzongsheng.github.io/fancybox/jquery.fancybox.pack.js"&gt;&lt;/script&gt;

&lt;script&gt;
$(document).ready(function() {
    $('.fancybox').fancybox();
});
&lt;/script&gt;
3 Add html code in your own page like this:
&lt;a href="http://lvzongsheng.github.io/images/about/pic2.jpg" class="fancybox" rel="gallery" title="摄于杭州钱塘江大桥"&gt;&lt;img src="http://lvzongsheng.github.io/images/about/pic2_m.jpg" /&gt;&lt;/a&gt;
&lt;a href="http://lvzongsheng.github.io/images/about/pic4.jpg" class="fancybox" rel="gallery" title="摄于杭州云栖竹径"&gt;&lt;img src="http://lvzongsheng.github.io/images/about/pic4_m.jpg" /&gt;&lt;/a&gt;
&lt;a href="http://lvzongsheng.github.io/images/about/pic5.jpg" class="fancybox" rel="gallery" title="摄于绍兴孔乙己酒家"&gt;&lt;img src="http://lvzongsheng.github.io/images/about/pic5_m.jpg" /&gt;&lt;/a&gt;
&lt;a href="http://lvzongsheng.github.io/images/about/pic4.jpg" class="fancybox" rel="gallery" title="摄于杭州云栖竹径"&gt;&lt;img src="http://lvzongsheng.github.io/images/about/pic4_m.jpg" /&gt;&lt;/a&gt;
</code></pre>

<p>FancyBox除了图片之外，还支持视频等其他多媒体形式，要得到更多信息，可以参见官网。</p>

<h3>2.2 搜索的优化</h3>

<p>为了使搜索引擎更好的找到我们的文章，我参照<a href="http://dinever.com/blog/2013/01/23/zhuan-zai-fan-yi-octopresszhong-de-seo-youhua/">Octopress中的搜索引擎优化</a>为每篇元素添加meta元素，优化搜索
当你使用rake new_post[title]生成文章时，layout、title、date、comments这些关键属性会自动生成，但如果你再为它增加两个关键词keywords和description，Octopress便会在rake generate时自动为这篇文章加上meta元素。</p>

<pre><code>layout: post
title: "octopress_setup"
date: 2013-08-28 23:34
comments: true
keywords: Octopress
description: Octopress 安装 配置
</code></pre>

<p>那么在生产页面时，就会有</p>

<pre><code>&lt;meta name="description" content="Octopress 安装 配置"&gt;
&lt;meta name="keywords" content="Octopress"&gt;
</code></pre>

<p>现在我们还要为首页添加meta标签。首先在_config.yml中加入keywords和description关键字</p>

<pre><code>title: Coco
subtitle: A blog for Recording.
author: Coco
simple_search: http://google.com/search
description: cocolighter algorithms data structure computer
keywords: cocolighter algorithms data structure computer
</code></pre>

<p>然后在source/_includes/head.html做如下修改</p>

<pre><code>{\% if page.keywords \%}&lt;meta name="keywords" content="Octopress"&gt;{\% else if site.keywords\%}&lt;meta name="keywords" content="cocolighter algorithms data structure computer"&gt;{\% endif \%}
</code></pre>
]]></content>
  </entry>
  
</feed>
